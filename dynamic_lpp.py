"""
This file contains my main program. The program uses Google's OR tools to implement a
linear programming algorithm to the given scenario. The scenario is based on the rules
specified in the rules class, and the transactions given. The constraints for the matrix,
as well as the maximization function and printed outputs are all dynamically generated by
evaluating formatted strings.

This is much quicker and more reliable that the brute force approach especially as the number
of rules in the rules list increases.
"""
from ortools.linear_solver import pywraplp

def find_defined_merchants(rules: list, monthly: dict) -> dict:
    """Helper function to return a dictionary of "relevant" merchants that are defined in the rules list as
    well as merchants defined in the monthly spendings list.

    Args:
        - spendings: dictionary containing total monthly spendings at merchants in a month
        - rules: a list of tupels containg the rules for an amount of rewards points

    Returns:
        - merchants: dictionary of "relevant" merchants for this set of transactions and rules
    """
    merchants = {}
    for rule in rules:
        for merchant in rule[1].keys():
            if merchant in monthly.keys():
                if merchant not in merchants:
                    merchants[merchant] = ""
    return merchants


def rule_applicable(rule: dict, monthly: dict) -> bool:
    """Helper function to return whether a rule is applicable for the given month's spendings.

    Args:
        - monthly: dictionary containing total monthly spendings at merchants in a month
        - rule: the rule to check compatability with

    Returns:
        - app: True if rule is applicable, False otherwise
    """
    app = True
    for shop in rule.keys():
        if shop not in monthly.keys():
            app = False
    return app


def generate_constraints(rules: list, monthly: dict) -> tuple:
    """Generates and returns the LPP's constraint formulas as strings as well as what rules
    are valid for each equation.

    Args:
        - rules: a list of tupels containg the rules for an amount of rewards points
        - monthly: dictionary containing total monthly spendings at merchants in a month
        
    Returns:
        - (exprs, valid_rules): tuple of dictionary containing equations and a set of valid rules
    """
    exprs = find_defined_merchants(rules, monthly)
    valid_rules = set()
    for i in range(1, len(rules)):
        for shop in exprs.keys():
            if rule_applicable(rules[i][1], monthly):
                if shop in rules[i][1]:
                    valid_rules.add(i)
                    if exprs[shop] == "": # first rule doesn't contain addition
                        exprs[shop] = exprs[shop] + f"{rules[i][1][shop]}*x[{i}]"
                        # expressions are in the form of "points*rule", i.e. 500*x[1]
                    else:
                        exprs[shop] = exprs[shop] + f" + {rules[i][1][shop]}*x[{i}]"
    
    # need to generate equation for leftover spendings
    remainder = ""
    for equation in exprs.keys():
        # first string needs to contain the equality symbol
        if remainder == "":
            remainder = remainder + f"x[{len(rules)}] <= ({monthly[equation]} - ({exprs[equation]}))"
            # remainder equation will be in the form of "x[7] <= 75 - (500*x[1])"
            # remainder value less than the calculated values of rest of equations
        else:
            remainder = remainder + f" + ({monthly[equation]} - ({exprs[equation]}))"
        # add the evaluating equality to end of each merchant's equation
        exprs[equation] = exprs[equation] + f" <= {monthly[equation]}"
    
    # generate and add the value of spendings not related to any of the rules
    other = 0
    for shop in monthly.keys():
        if shop not in exprs.keys():
            other += monthly[shop]
    remainder = remainder + f" + {other}"

    exprs["remainder"] = remainder
   
    return (exprs, valid_rules)


def gen_maximizer_expr(rules: list, valid_rules: set) -> str:
    """Generates and returns the LPP's maximzer function as a string. In this algorithm,
    the maximizing function is the points accumulated from the coefficients chosen.

    Args:
        - rules: a list of tupels containg the rules for an amount of rewards points
        - valid_rules: set of applicable rules for a given month's spendings
        
    Returns:
        - max: the maximizing function represented as a string where each term is points*times_applied
    """
    max = ""
    for i in valid_rules:
        if max == "":
            max = max + f"x[{i}]*{rules[i][0]}"
        else:
            max = max + f" + x[{i}]*{rules[i][0]}"
    max = max + f" + x[{len(rules)}]*{rules[0][0]}"
    
    return max


def dynamic_lpp_points_calc(rules: list, monthly: dict):
    """Main algorithm implementation of Google's OR tools that solves and prints
    the number of times each rule is applied as well as the maximum points generated
    with that set of coefficients.

    Args:
        - rules: a list of tupels containg the rules for an amount of rewards points
        - monthly: dictionary containing total monthly spendings at merchants in a month
        
    See main and lpp_optimizer.py for further understanding of how this dynamically
    generated version of this function works.
    """
    solver = pywraplp.Solver.CreateSolver('CBC') # CBC algorithm

    x = [0] # list of variables stored in array

    for i in range(1, len(rules) + 1):
        x.append(solver.IntVar(0, solver.infinity(), f"x{i}"))

    generated = generate_constraints(rules, monthly)
    constraints, valids = generated[0], generated[1]

    for expr in constraints.values():
        solver.Add(eval(expr))

    max = gen_maximizer_expr(rules, valids)

    solver.Maximize(eval(max))

    status = solver.Solve()

    if status == pywraplp.Solver.OPTIMAL:
        print('Solution:')
        print('Total points =', int(solver.Objective().Value()))
        for i in range(1, len(rules) + 1):
            print(f"Rule {i}: {int(x[i].solution_value())} times")
    else:
        print('The problem does not have an optimal solution.')
    
    return solver